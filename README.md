å‰è¨€
    æµ…æµ…è®°å½•ä¸€ä¸‹å¯¹KFå’Œå››å…ƒæ•°å§¿æ€è§£ç®—çš„å­¦ä¹ ï¼Œæ¬¢è¿å¤§å®¶æŒ‡æ­£ã€‚å¯¹äºEKFå’Œå››å…ƒæ•°ï¼Œç½‘ä¸Šçš„èµ„æ–™å·²ç»å¾ˆå……åˆ†äº†ï¼ŒDR_CANçš„å…¬å¼æ¨å¯¼çœŸçš„å¾ˆè¯¦ç»†ï¼Œè¿™é‡Œä¸å†èµ˜è¿°ï¼Œè¯¥æ–‡å¯¹ 
ğ‘¤
ğ‘
ğ‘–
ğ‘
ğ‘ 
 æ²¡æœ‰æ›´æ–°ï¼Œç†è§£åŸç†ä¹‹åè‡ªè¡ŒåŠ ä¸Šå³å¯ã€‚
åŸºäºEKFçš„å§¿æ€è§£ç®— - çŸ¥ä¹ (zhihu.com)
å››å…ƒæ•°EKFå§¿æ€æ›´æ–°ç®—æ³• - çŸ¥ä¹ (zhihu.com)
ä½¿ç”¨æ‰©å±•å¡å°”æ›¼æ»¤æ³¢ï¼ˆEKFï¼‰è¿›è¡ŒAHRSä¹è½´å§¿æ€èåˆ_ahrs å¡å°”æ›¼æ»¤æ³¢_@å¥”è·‘çš„èœ—ç‰›@çš„åšå®¢-CSDNåšå®¢
ã€å¡å°”æ›¼æ»¤æ³¢å™¨ã€‘1_é€’å½’ç®—æ³•_Recursive Processing_å“”å“©å“”å“©_bilibili
å®ç°æ­¥éª¤
1.çŠ¶æ€é‡(å…ˆéªŒä¼°è®¡)
    åœ¨KFä¸­ï¼Œè¿™é‡Œè®¾ç½®çš„çŠ¶æ€é‡ 
ğ‘¥
ğ‘˜
 å³æ˜¯æœºä½“çš„å››å…ƒæ•° 
(4)
ğ‘
=
[
ğ‘
0
ğ‘
1
ğ‘
2
ğ‘
3
]
ğ‘‡
 
(5)
ğ‘¥
ğ‘˜
=
ğ‘
 
    çŠ¶æ€æ–¹ç¨‹å¦‚ä¸‹
(6)
ğ‘¥
ğ‘˜
=
ğ´
ğ‘¥
ğ‘˜
âˆ’
1
+
ğ‘Š
     å…¶ä¸­ 
ğ‘Š
 ~ 
ğ‘
(
0
,
ğ‘„
)
 ,æˆ‘ä»¬å®é™…èƒ½å¤Ÿè®¡ç®—çš„åªæœ‰å‰åŠéƒ¨åˆ†
(7)
ğ‘¥
^
ğ‘˜
âˆ’
=
ğ´
ğ‘¥
^
ğ‘˜
âˆ’
1
 
    çŠ¶æ€è½¬ç§»çŸ©é˜µAè¦ä»å››å…ƒæ•°å¾®åˆ†æ–¹ç¨‹ä¸­å¾—æ¥
    å·²çŸ¥å››å…ƒæ•°å¾®åˆ†æ–¹ç¨‹å¦‚ä¸‹:
(8)
ğ‘
Ë™
=
1
2
[
0
âˆ’
ğ‘¤
ğ‘¥
âˆ’
ğ‘¤
ğ‘¦
âˆ’
ğ‘¤
ğ‘§
ğ‘¤
ğ‘¥
0
ğ‘¤
ğ‘§
âˆ’
ğ‘¤
ğ‘¦
ğ‘¤
ğ‘¦
âˆ’
ğ‘¤
ğ‘§
0
ğ‘¤
ğ‘¥
ğ‘¤
ğ‘§
ğ‘¤
ğ‘¦
âˆ’
ğ‘¤
ğ‘¥
0
]
ğ‘
 
(9)
Î©
=
[
0
âˆ’
ğ‘¤
ğ‘¥
âˆ’
ğ‘¤
ğ‘¦
âˆ’
ğ‘¤
ğ‘§
ğ‘¤
ğ‘¥
0
ğ‘¤
ğ‘§
âˆ’
ğ‘¤
ğ‘¦
ğ‘¤
ğ‘¦
âˆ’
ğ‘¤
ğ‘§
0
ğ‘¤
ğ‘¥
ğ‘¤
ğ‘§
ğ‘¤
ğ‘¦
âˆ’
ğ‘¤
ğ‘¥
0
]
 
    åœ¨æ•°å­—ç³»ç»Ÿä¸­ï¼Œæ›´æ–°å››å…ƒæ•°çš„æ–¹å¼
(10)
ğ‘
(
ğ‘¡
+
Î”
ğ‘¡
)
=
(
ğ¼
4
+
1
2
Î©
Î”
ğ‘¡
)
ğ‘
ğ‘¡
     å³å¾—å®Œæ•´çš„çŠ¶æ€æ–¹ç¨‹
(11)
ğ‘¥
^
ğ‘˜
âˆ’
=
(
ğ¼
4
+
1
2
Î©
Î”
ğ‘¡
)
ğ‘¥
^
ğ‘˜
âˆ’
1
     è¿™é‡Œï¼Œæˆ‘ä»¬å¾—åˆ°äº†çŠ¶æ€è½¬ç§»çŸ©é˜µA
(12)
ğ´
=
(
ğ¼
4
+
1
2
Î©
Î”
ğ‘¡
)
 
2.è®¡ç®—å…ˆéªŒè¯¯å·®åæ–¹å·®
(13)
ğ‘ƒ
ğ‘˜
âˆ’
=
ğ´
ğ‘ƒ
ğ‘˜
âˆ’
1
ğ´
ğ‘‡
+
ğ‘„
     è¿™é‡Œå¥—å…¬å¼å³å¯ã€‚
3.è§‚æµ‹é‡
    è§‚æµ‹æ–¹ç¨‹å¦‚ä¸‹
(14)
ğ‘
ğ‘˜
=
ğ»
ğ‘¥
ğ‘˜
+
ğ‘‰
 
å…¶ä¸­ 
ğ‘‰
 ~ 
ğ‘
(
0
,
ğ‘…
)
 
è¿™é‡Œè§‚æµ‹é‡ 
ğ‘
ğ‘˜
 å°±æ˜¯åŠ é€Ÿåº¦è®¡é‡‡é›†åˆ°çš„æ•°æ®ã€‚
(15)
ğ‘
ğ‘˜
=
[
ğ‘
ğ‘¥
ğ‘
ğ‘¦
ğ‘
ğ‘§
]
ğ‘‡
 åœ¨ä¸œåŒ—å¤©åæ ‡ç³»ä¸‹ï¼Œæˆ‘ä»¬å®šä¹‰é‡åŠ›åŠ é€Ÿåº¦ 
ğº
 å‘é‡ï¼Œä»¥åŠæœºä½“çš„åŠ é€Ÿåº¦å‘é‡ 
ğº
ğ‘
 
(16)
ğº
=
[
0
0
1
]
ğ‘‡
 
(17)
ğº
ğ‘
=
[
ğ‘
ğ‘¥
â€²
ğ‘
ğ‘¦
â€²
ğ‘
ğ‘§
â€²
]
ğ‘‡
 æ ¹æ® 
ğº
=
ğ¶
ğ‘›
ğ‘
ğº
ğ‘
 
(18)
ğº
ğ‘
=
ğ¶
ğ‘
ğ‘›
[
0
0
1
]
=
[
2
ğ‘
1
ğ‘
3
âˆ’
2
ğ‘
0
ğ‘
2
2
ğ‘
2
ğ‘
3
+
2
ğ‘
0
ğ‘
1
1
âˆ’
2
ğ‘
1
2
âˆ’
2
ğ‘
2
2
]
 å‰é¢çš„æ–‡ç« ä¸­é‡Œ 
1
âˆ’
2
ğ‘
1
2
âˆ’
2
ğ‘
2
2
 ä¸ 
ğ‘
0
2
âˆ’
ğ‘
1
2
âˆ’
ğ‘
2
2
+
ğ‘
3
2
 ç­‰ä»·ï¼Œè¿™é‡Œä½¿ç”¨çš„å››å…ƒæ•°éƒ½æ˜¯å•ä½å››å…ƒæ•°ï¼Œåœ¨å…·ä½“ä»£ç ä¸­ä¸€å®šè¦å½’ä¸€åŒ–ã€‚å¯¹ä¸Šå¼æ±‚é›…å…‹æ¯”çŸ©é˜µï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°è§‚æµ‹çŸ©é˜µ 
ğ»
 
(19)
ğ»
=
[
âˆ’
2
ğ‘
2
2
ğ‘
3
âˆ’
2
ğ‘
0
2
ğ‘
1
2
ğ‘
1
2
ğ‘
0
2
ğ‘
3
2
ğ‘
2
2
ğ‘
0
âˆ’
2
ğ‘
1
âˆ’
2
ğ‘
2
2
ğ‘
3
]
 4.è®¡ç®—å¡å°”æ›¼å¢ç›Š
(20)
ğ¾
ğ‘˜
=
ğ‘ƒ
ğ‘˜
âˆ’
ğ»
ğ‘‡
ğ»
ğ‘ƒ
ğ‘˜
âˆ’
ğ»
ğ‘‡
+
ğ‘…
 è¿™é‡Œä¹Ÿå¥—å…¬å¼ã€‚
5.åéªŒä¼°è®¡
(21)
ğ‘¥
^
ğ‘˜
=
ğ‘¥
^
ğ‘˜
âˆ’
1
âˆ’
+
ğ¾
ğ‘˜
(
ğ‘
ğ‘˜
âˆ’
ğ»
ğ‘¥
^
ğ‘˜
âˆ’
1
âˆ’
)
 6.æ›´æ–°è¯¯å·®åæ–¹å·®
(22)
ğ‘ƒ
ğ‘˜
=
(
ğ¼
4
âˆ’
ğ¾
ğ‘˜
ğ»
)
ğ‘ƒ
ğ‘˜
âˆ’
 æ•´ä¸ªè®¡ç®—æµç¨‹å°±æ˜¯è¿™äº›äº†ã€‚åœ¨å¾—åˆ°è§‚æµ‹çŸ©é˜µ 
ğ»
 ä¸­ï¼ŒæŠŠåŸæœ¬çš„éçº¿æ€§å‡½æ•°(18)ï¼Œé€šè¿‡æ±‚é›…å¯æ¯”çŸ©é˜µï¼Œç›¸å½“äºä¸€çº§çš„æ³°å‹’å±•å¼€ï¼Œå®Œæˆäº†çº¿æ€§åŒ–ã€‚
Pythonæºç 
githubåœ°å€ï¼škalworth/EKF.py: åŸºäºæ‰©å±•å¡å°”æ›¼(EKF)çš„å››å…ƒæ•°å§¿æ€è§£ç®—(å…­è½´) (github.com)
ä½¿ç”¨çš„æ•°æ®æ˜¯é€šè¿‡ä¸²å£æ‰“å°ä¿å­˜ä¸‹æ¥çš„ï¼Œé¡ºåºæ˜¯ax,ay,az,gx,gy,gz
2024/4/29æ³¨ï¼špythonä»£ç è¿è¡Œçš„æ—¶å€™ï¼Œæ³¨æ„åšå•ä½è½¬æ¢ï¼Œxlxsé‡Œé¢çš„è§’é€Ÿåº¦å•ä½æ˜¯deg/sï¼ŒåŠ é€Ÿåº¦å•ä½æ˜¯gï¼Œéœ€è¦è½¬æ¢æˆrad/sä»¥åŠmÂ²/så†è¿›è¡Œè¿ç®—ï¼Œæ³¨æ„ï¼ï¼ï¼(å½“å‰pythonä»£ç é‡Œæ²¡æœ‰åŠ ï¼Œæ‡’å¾—æ”¹äº†ï¼Œåé¢æœ‰Cå’ŒMatlabç‰ˆæœ¬çš„)

åŠ é€Ÿåº¦è®¡ä¸é™€èºä»ªæ•°æ®
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

imu_data = pd.read_csv("C:/Serial Debug 2023-8-12 174233.csv")
imu_data = np.asarray(imu_data)

Q = [0.01] * 4
R = [1000.0] * 3
I = [1.0] * 4
P = [10000.0] * 4

class EKF():
    def __init__(self, period):
        self.Q_matrix  = np.diag(Q)
        self.R_matrix  = np.diag(R)
        self.I_matrix  = np.diag(I)
        self.halfT     = 1/2 * period
        self.P_matrix  = np.diag(P)
        self.A_matrix  = np.zeros([4,4])
        self.H_matrix  = np.zeros([3,4])
        self.K_matrix  = np.zeros([4,3])
        self.K_vector  = np.zeros([4,])
        self.T_vector  = np.zeros([3,])
        self.HX_vector = np.zeros([3,])
        self.Z_vector  = np.zeros([3,])
        self.pitch     = 0.0
        self.roll      = 0.0
        #self.q         = np.random.randn(4)
        self.q         = np.array([1.0,0.0,0.0,0.0])
        self.pitch_list= []
        self.roll_list = []
        self.a_pitch   = 0.0
        self.a_roll    = 0.0
        self.a_pitch_list = []
        self.a_roll_list = []

    def normalizeQuternion(self, q: np.ndarray):

        norm = np.linalg.norm(q,2)

        norm_q = q/norm

        return  norm_q

    def priori(self, gx, gy, gz):

        gx_ = gx * self.halfT
        gy_ = gy * self.halfT
        gz_ = gz * self.halfT

        self.A_matrix = np.array([
            [1, -gx_, -gy_, -gz_],
            [gx_, 1,   gz_, -gy_],
            [gy_, -gz_, 1,   gx_],
            [gz_, gy_, -gx_,   1]
        ])

        self.q = np.dot(self.A_matrix,self.q)

    def cal_P_matrix(self):
        self.P_matrix = np.dot(np.dot(self.A_matrix,self.P_matrix),np.transpose(self.A_matrix)) + self.Q_matrix

    def cal_HX_vector(self, q,ax, ay, az):
        self.H_matrix = np.array([
            [-2*q[2], 2*q[3], -2*q[0], 2*q[1]],
            [2*q[1],  2*q[0],  2*q[3], 2*q[2]],
            [2*q[0], 2*q[1], 2*q[2], 2*q[3]]
        ])
        self.HX_vector = np.array([
            2*q[1]*q[3] - 2*q[0]*q[2],
            2*q[2]*q[3] + 2*q[0]*q[1],
            1 - 2*(q[1]**2) - 2*(q[2]**2)
        ])

        self.Z_vector = np.array([ax,ay,az])

    def cal_K_matrix(self):
        self.K_matrix = np.dot(
            np.dot(self.P_matrix,np.transpose(self.H_matrix)),
            np.linalg.inv(
                np.dot(
                    np.dot(
                        self.H_matrix,self.P_matrix
                    ),np.transpose(self.H_matrix)
                ) + self.R_matrix
            )
        )

    def posterior(self):
        # åŸæ¥æ˜¯self.q_k æ”¹æ­£ä¸º self.q
        self.q = self.q + np.dot(
            self.K_matrix,
            self.Z_vector - self.HX_vector
        )

    def update_P_matrix(self):
        self.P_matrix = np.dot(
            self.I_matrix - np.dot(self.K_matrix,self.H_matrix),
            self.P_matrix
        )

    def Quternion2Angle(self,q):
        self.roll = -np.arcsin(2*(q[0]*q[2] - q[1]*q[3])) * 57.3
        self.pitch = np.arctan2((2*(q[0]*q[1] + q[1]*q[3])), (2*(q[0]*q[0] + q[3]*q[3]) - 1.0)) * 57.3
        self.pitch_list.append(self.pitch)
        self.roll_list.append(self.roll)

    def plot_angle(self, angle_list, color, angle_name):
         x = np.arange(0, len(angle_list), 1)
         y = np.array(angle_list)
         plt.plot(x,y,color=color,linewidth=1,label=angle_name)

    def cal_a_angle(self, ax, ay, az):
        self.a_pitch = np.arctan2(ay,az) * 57.3
        self.a_roll = np.arctan(ax/np.sqrt(ay*ay+az*az)) * 57.3
        self.a_pitch_list.append(self.a_pitch)
        self.a_roll_list.append(self.a_roll)


    def EKF_update(self,imu_sorce_data):
        for i in range(2):
            for data in imu_sorce_data:
                self.q = self.normalizeQuternion(self.q)
                self.priori(data[3], data[4], data[5])
                self.q = self.normalizeQuternion(self.q)
                self.cal_P_matrix()
                self.cal_HX_vector(self.q, data[0], data[1], data[2])
                self.cal_K_matrix()
                self.posterior()
                self.update_P_matrix()
                self.Quternion2Angle(self.q)
                self.cal_a_angle(data[0],data[1],data[2])

        plt.figure()  # ç”»å¸ƒå°ºå¯¸é»˜è®¤
        self.plot_angle(self.pitch_list,'red','pitch')
        self.plot_angle(self.a_pitch_list, 'blue', 'roll')
        plt.legend(['EKF_pitch','acc_pitch'], loc='best')
        plt.figure()  # ç”»å¸ƒå°ºå¯¸é»˜è®¤
        self.plot_angle(self.roll_list,'green','pitch')
        self.plot_angle(self.a_roll_list, 'black', 'roll')
        plt.legend(['EKF_roll','acc_roll'], loc='best')
        plt.show()

if __name__ == "__main__":
    EKF_model = EKF(period=0.0001)
    EKF_model.EKF_update(imu_data)
   å¯¹æ»¤æ³¢æ•ˆæœå½±å“è¾ƒå¤§çš„å› ç´ ï¼šæœºä½“å››å…ƒæ•°qçš„åˆå€¼ä»¥åŠé‡‡æ ·å‘¨æœŸã€‚å¡å°”æ›¼å¢ç›Šä¼šæ”¶æ•›ï¼ŒQRé˜µå‚æ•°åˆç†å³å¯ã€‚

rollè§’ç»è¿‡EKFä¸åªç”¨åŠ é€Ÿåº¦è®¡è§£ç®—ä½œæ¯”è¾ƒ

å±€éƒ¨æ”¾å¤§
    æ¯”è¾ƒæ˜æ˜¾çš„æ˜¯ç»è¿‡EKFä¹‹åï¼Œæ³¢å½¢æ›´åŠ å¹³æ»‘ï¼Œåˆ©äºè¿›ä¸€æ­¥çš„ä½¿ç”¨ã€‚
    ä»¥ä¸‹æ˜¯åœ¨MCUä¸­è¿è¡Œçš„ç¨‹åºï¼Œå¦‚æœæœ‰é”™çš„åœ°æ–¹æ¬¢è¿æŒ‡å‡ºæ¥ã€‚
typedef struct {
    float period;                       // å§¿æ€æ›´æ–°å‘¨æœŸ
    float half_T;                       // å§¿æ€æ›´æ–°å‘¨æœŸçš„1/2      å•ä½ï¼šs

    float I_matrix[16];                 // å•ä½çŸ©é˜µ              4 * 4
    float Q_matrix[16];                 // è¿‡ç¨‹å™ªå£°åæ–¹å·®çŸ©é˜µ      4 * 4
    float R_matrix[9];                  // è§‚æµ‹å™ªå£°åæ–¹å·®çŸ©é˜µ      3 * 3
    float A[16];                        // çŠ¶æ€è½¬ç§»çŸ©é˜µ           4 * 4
    float H[12];                        // è§‚æµ‹çŸ©é˜µ              3 * 4
    float p_hat[16];                    // è¯¯å·®åæ–¹å·®çŸ©é˜µ         4 * 4
    float K[12];                        // å¡å°”æ›¼å¢ç›ŠçŸ©é˜µ         4 * 3
    float Kq[4];                        // å››å…ƒæ•°å¡å°”æ›¼å¢ç›Š        4 * 1
    float T[3];                         // æ®‹å·®å‘é‡               3 * 1
    float q[4];                         // æœºä½“å››å…ƒæ•°             4 * 1
    float q_k[4];                       // ä¼˜åŒ–åçš„å››å…ƒæ•°          4 * 1

    float vector_hat[3];                // è§‚æµ‹é‡åŠ›åŠ é€Ÿåº¦          3 * 1

    void (*filter)(float,float,float,   // EKFæ›´æ–°å§¿æ€å‡½æ•°æŒ‡é’ˆ
                        float,float,float);
}EKF_StructTypeDef;

    å…³äºEKFçš„ç»“æ„ä½“
static EKF_StructTypeDef      imu_ekf;                              // EKF
     ç„¶åæ˜¯åˆå§‹åŒ–ï¼Œ  å™ªå£°çŸ©é˜µä¸æˆ‘ä»¬çš„çŠ¶æ€é‡å’Œè§‚æµ‹é‡æ˜¯å¯¹åº”çš„ã€‚ åæ–¹å·®çŸ©é˜µå¯¹åº”é¢„æµ‹å‘é‡çš„åæ–¹å·®ï¼Œ  åæ–¹å·®çŸ©é˜µå¯¹åº”è§‚æµ‹å‘é‡çš„åæ–¹å·®ã€‚  çš„å€¼ä¸é¢„æµ‹å€¼çš„æƒé‡æˆåæ¯”ï¼Œå³QçŸ©é˜µä¸­åæ–¹å·®è¶Šå°ï¼Œè¶Šç›¸ä¿¡é¢„æµ‹å€¼(å¯¹åº”ç›¸ä¿¡è§’é€Ÿåº¦)ï¼ŒRçš„å€¼ä¸è§‚æµ‹å€¼çš„æƒé‡æˆåæ¯”ï¼Œå³RçŸ©é˜µä¸­åæ–¹å·®è¶Šå°ï¼Œè¶Šç›¸ä¿¡è§‚æµ‹å€¼(å¯¹åº”ç›¸ä¿¡åŠ é€Ÿåº¦)ã€‚
/**
  * @brief  EKFåˆå§‹åŒ–
  * @param  None
  * @note   None
  * @retval None
  */
static void EKF_init(void)
{

    imu_ekf.period = 0.001;  // å§¿æ€è§£ç®—å‘¨æœŸ 1ms
    imu_ekf.half_T = imu_ekf.period / 2.0f;

    imu_ekf.I_matrix[0] = 1; imu_ekf.I_matrix[1] = 0;   imu_ekf.I_matrix[2] = 0;  imu_ekf.I_matrix[3] = 0;
    imu_ekf.I_matrix[4] = 0; imu_ekf.I_matrix[5] = 1;   imu_ekf.I_matrix[6] = 0;  imu_ekf.I_matrix[7] = 0;
    imu_ekf.I_matrix[8] = 0; imu_ekf.I_matrix[9] = 0;   imu_ekf.I_matrix[10] = 1; imu_ekf.I_matrix[11] = 0;
    imu_ekf.I_matrix[12] = 0;imu_ekf.I_matrix[13] = 0;  imu_ekf.I_matrix[14] = 0; imu_ekf.I_matrix[15] = 1;

    float Q_Val = 0.01;
    imu_ekf.Q_matrix[0] = Q_Val; imu_ekf.Q_matrix[1] = 0;     imu_ekf.Q_matrix[2] = 0;     imu_ekf.Q_matrix[3] = 0;
    imu_ekf.Q_matrix[4] = 0;     imu_ekf.Q_matrix[5] = Q_Val; imu_ekf.Q_matrix[6] = 0;     imu_ekf.Q_matrix[7] = 0;
    imu_ekf.Q_matrix[8] = 0;     imu_ekf.Q_matrix[9] = 0;     imu_ekf.Q_matrix[10] = Q_Val;imu_ekf.Q_matrix[11] = 0;
    imu_ekf.Q_matrix[12] = 0;    imu_ekf.Q_matrix[13] = 0;    imu_ekf.Q_matrix[14] = 0;    imu_ekf.Q_matrix[15] = Q_Val;

    float R_Val = 1000000;
    imu_ekf.R_matrix[0] = R_Val; imu_ekf.R_matrix[1] = 0;     imu_ekf.R_matrix[2] = 0;
    imu_ekf.R_matrix[3] = 0;     imu_ekf.R_matrix[4] = R_Val; imu_ekf.R_matrix[5] = 0;
    imu_ekf.R_matrix[6] = 0;     imu_ekf.R_matrix[7] = 0;     imu_ekf.R_matrix[8] = R_Val;

    float P_Val = 100000;
    imu_ekf.p_hat[0] = P_Val;imu_ekf.p_hat[1] = 0;    imu_ekf.p_hat[2] = 0;     imu_ekf.p_hat[3] = 0;
    imu_ekf.p_hat[4] = 0;    imu_ekf.p_hat[5] = P_Val;imu_ekf.p_hat[6] = 0;     imu_ekf.p_hat[7] = 0;
    imu_ekf.p_hat[8] = 0;    imu_ekf.p_hat[9] = 0;    imu_ekf.p_hat[10] = P_Val;imu_ekf.p_hat[11] = 0;
    imu_ekf.p_hat[12] = 0;   imu_ekf.p_hat[13] = 0;   imu_ekf.p_hat[14] = 0;    imu_ekf.p_hat[15] = P_Val;

    imu_ekf.q[0] = 1;
    imu_ekf.q[1] = 0;
    imu_ekf.q[2] = 0;
    imu_ekf.q[3] = 0;

    imu_ekf.q_k[0] = 1;
    imu_ekf.q_k[1] = 0;
    imu_ekf.q_k[2] = 0;
    imu_ekf.q_k[3] = 0;

    imu_ekf.filter = ekf_update;
}
æ¥ä¸‹æ¥å°±æ˜¯å››å…ƒæ•°çš„æ›´æ–°äº†ï¼Œå®ç°ä¸Šæ–‡æåˆ°çš„è¿‡çš„å®Œæ•´çš„EKFçš„è®¡ç®—æµç¨‹ï¼Œå…³äºçŸ©é˜µè¿ç®—çš„å‡½æ•°ï¼Œæˆ‘æ‰¾çš„GPTç”Ÿæˆçš„ï¼Œè‡ªå·±ç”¨dev-cè¿˜éªŒè¯äº†ä¸€ä¸‹ï¼Œè®¡ç®—å¡å°”æ›¼å¢ç›Šçš„æ—¶å€™éœ€è¦æ±‚çŸ©é˜µçš„é€†é˜µï¼Œæˆ‘åªç”¨äº†ä¸€ä¸ªåªèƒ½æ±‚3Ã—3çš„é€†çŸ©é˜µçš„å‡½æ•°ã€‚(äº‹å®æ˜¯ï¼Œæ²¡æ‰¾åˆ°åˆé€‚çš„çŸ©é˜µåº“ï¼Œå‚è€ƒçš„å‡ ä½å¤§ä½¬ç”¨çš„æ˜¯ä¸€ç»´çš„æ•°ç»„ï¼Œè®¾å®šä¸€ä¸ªå½¢çŠ¶çš„çŸ©é˜µ)ã€‚æƒ³è¦è·å–æ¬§æ‹‰è§’ï¼Œåšä¸€æ­¥è½¬æ¢å³å¯ã€‚
/**
  * @brief  æ‰©å±•å¡å°”æ›¼ ä¼˜åŒ–å››å…ƒæ•°
  * @param  gx      xè½´è§’é€Ÿåº¦
  * @param  gy      yè½´è§’é€Ÿåº¦
  * @param  gz      zè½´è§’é€Ÿåº¦
  * @param  ax      xè½´åŠ é€Ÿåº¦
  * @param  ay      yè½´åŠ é€Ÿåº¦
  * @param  az      zè½´åŠ é€Ÿåº¦
  * @note   None
  * @retval None
  */
static void ekf_update(float gx, float gy, float gz, float ax, float ay, float az)
{
#define DIV_180_PI       (float)(57.295779513f)
#define GRAVITY          (float)(9.8f)

    // å•ä½æ¢ç®—, deg/sè½¬æ¢åˆ°rad/s, gæ¢ç®—åˆ°mÂ²/2
    gx /= DIV_180_PI;
    gy /= DIV_180_PI;
    gz /= DIV_180_PI;

    ax *= GRAVITY;
    ay *= GRAVITY;
    az *= GRAVITY;

    normalize_quternion(imu_ekf.q);
    /****************************** çŠ¶æ€æ–¹ç¨‹ ******************************/
    /* 1/2å§¿æ€æ›´æ–°å‘¨æœŸèµ‹å€¼ */
    float half_T = imu_ekf.half_T;
    /* å››å…ƒæ•°å¾®åˆ†æ–¹ç¨‹ç¦»æ•£åŒ– */
    imu_ekf.q[0] += (-imu_ekf.q[1] * gx - imu_ekf.q[2] * gy - imu_ekf.q[3] * gz) * (float)half_T;
    imu_ekf.q[1] += ( imu_ekf.q[0] * gx + imu_ekf.q[2] * gz - imu_ekf.q[3] * gy) * (float)half_T;
    imu_ekf.q[2] += ( imu_ekf.q[0] * gy - imu_ekf.q[1] * gz + imu_ekf.q[3] * gx) * (float)half_T;
    imu_ekf.q[3] += ( imu_ekf.q[0] * gz + imu_ekf.q[1] * gy - imu_ekf.q[2] * gx) * (float)half_T;
    /*   å››å…ƒæ•° å½’ä¸€åŒ–    */
    normalize_quternion(imu_ekf.q);
    /*  çŠ¶æ€è½¬ç§»çŸ©é˜µèµ‹å€¼   */
    imu_ekf.A[0] =            1;  imu_ekf.A[1] = -gx * half_T; imu_ekf.A[2] = -gy * half_T;  imu_ekf.A[3] = -gz * half_T;
    imu_ekf.A[4] =  gx * half_T;  imu_ekf.A[5] =            1; imu_ekf.A[6] =  gz * half_T;  imu_ekf.A[7] = -gy * half_T;
    imu_ekf.A[8] =  gy * half_T;  imu_ekf.A[9] = -gz * half_T; imu_ekf.A[10]=            1;  imu_ekf.A[11]=  gx * half_T;
    imu_ekf.A[12]=  gz * half_T;  imu_ekf.A[13]=  gy * half_T; imu_ekf.A[14]= -gx * half_T;  imu_ekf.A[15]=            1;
    /****************************** çŠ¶æ€æ–¹ç¨‹ ******************************/

    /**************************** ä¼°ç®—åæ–¹å·®çŸ©é˜µ ***************************/
    float temp_matrix1[16];
    float temp_matrix2[16];
    float temp_matrix3[16];
    matrix_multiply(imu_ekf.A,imu_ekf.p_hat,temp_matrix1,4,4,4);
    matrix_transpose(imu_ekf.A,temp_matrix2,4,4);
    matrix_multiply(temp_matrix1,temp_matrix2,temp_matrix3,4,4,4);
    matrix_add(temp_matrix3,imu_ekf.Q_matrix,imu_ekf.p_hat,4,4);
    /**************************** ä¼°ç®—åæ–¹å·®çŸ©é˜µ ***************************/

    /****************************** è§‚æµ‹æ–¹ç¨‹ ******************************/
    /*   è§‚æµ‹å‘é‡è®¡ç®—  */
    imu_ekf.vector_hat[0] = 2 * (imu_ekf.q[1] * imu_ekf.q[3] - imu_ekf.q[0] * imu_ekf.q[2]);
    imu_ekf.vector_hat[1] = 2 * (imu_ekf.q[2] * imu_ekf.q[3] + imu_ekf.q[0] * imu_ekf.q[1]);
    imu_ekf.vector_hat[2] = imu_ekf.q[0] * imu_ekf.q[0] - imu_ekf.q[1] * imu_ekf.q[1] - imu_ekf.q[2] * imu_ekf.q[2] + imu_ekf.q[3] * imu_ekf.q[3];
    /*    è§‚æµ‹çŸ©é˜µèµ‹å€¼    */
    imu_ekf.H[0] = -2 * imu_ekf.q[2]; imu_ekf.H[1] =  2 * imu_ekf.q[3]; imu_ekf.H[2] =  -2 * imu_ekf.q[0]; imu_ekf.H[3] =  2 * imu_ekf.q[1];
    imu_ekf.H[4] =  2 * imu_ekf.q[1]; imu_ekf.H[5] =  2 * imu_ekf.q[0]; imu_ekf.H[6] =   2 * imu_ekf.q[3]; imu_ekf.H[7] =  2 * imu_ekf.q[2];
    imu_ekf.H[8] =  2 * imu_ekf.q[0]; imu_ekf.H[9] = -2 * imu_ekf.q[1]; imu_ekf.H[10] = -2 * imu_ekf.q[2]; imu_ekf.H[11] = 2 * imu_ekf.q[3];
    /****************************** è§‚æµ‹æ–¹ç¨‹ ******************************/

    /**************************** è®¡ç®—å¡å°”æ›¼å¢ç›Š ***************************/
    float temp_matrix4[12];
    float temp_matrix5[12];
    float temp_matrix6[9];
    float temp_matrix7[9];
    float temp_matrix8[9];
    float HT[12];
    matrix_transpose(imu_ekf.H,HT,3,4);
    matrix_multiply(imu_ekf.p_hat,HT,temp_matrix4,4,4,3);
    matrix_multiply(imu_ekf.H,imu_ekf.p_hat,temp_matrix5,3,4,4);
    matrix_multiply(temp_matrix5,HT,temp_matrix6,3,4,3);
    matrix_add(temp_matrix6,imu_ekf.R_matrix,temp_matrix7,3,3);
    calculateInverse(temp_matrix7,temp_matrix8);
    matrix_multiply(temp_matrix4,temp_matrix8,imu_ekf.K,4,3,3);
    /**************************** è®¡ç®—å¡å°”æ›¼å¢ç›Š ***************************/

    /****************************** è®¡ç®—æ®‹å·® ******************************/
    /*   å½’ä¸€åŒ–åŠ é€Ÿåº¦è®¡    */
    float norm = sqrtf(ax * ax + ay * ay + az* az);
    ax /= norm;
    ay /= norm;
    az /= norm;
    /*    è®¡ç®—æ®‹å·®å‘é‡    */
    imu_ekf.T[0] = ax - imu_ekf.vector_hat[0];
    imu_ekf.T[1] = ay - imu_ekf.vector_hat[1];
    imu_ekf.T[2] = az - imu_ekf.vector_hat[2];
    /****************************** è®¡ç®—æ®‹å·® ******************************/

    /*************************** åéªŒä¼°è®¡å››å…ƒæ•° ****************************/
    matrix_multiply(imu_ekf.K,imu_ekf.T,imu_ekf.Kq,4,3,1);
    /*    åéªŒå››å…ƒæ•°      */
    imu_ekf.q_k[0] = imu_ekf.q[0] + imu_ekf.Kq[0];
    imu_ekf.q_k[1] = imu_ekf.q[1] + imu_ekf.Kq[1];
    imu_ekf.q_k[2] = imu_ekf.q[2] + imu_ekf.Kq[2];
    imu_ekf.q_k[3] = imu_ekf.q[3] + imu_ekf.Kq[3];
    /*    å½’ä¸€åŒ–å››å…ƒæ•°     */
    normalize_quternion(imu_ekf.q_k);
    /*    æ›´æ–° å››å…ƒæ•°     */
    imu_ekf.q[0] = imu_ekf.q_k[0];
    imu_ekf.q[1] = imu_ekf.q_k[1];
    imu_ekf.q[2] = imu_ekf.q_k[2];
    imu_ekf.q[3] = imu_ekf.q_k[3];
    /*************************** åéªŒä¼°è®¡å››å…ƒæ•° ****************************/

    /*************************** æ›´æ–°åæ–¹å·®çŸ©é˜µ ****************************/
    float temp_matrix9[16];
    float temp_matrix10[16];
    float temp_matrix11[16];
    matrix_multiply(imu_ekf.K,imu_ekf.H,temp_matrix9,4,3,4);
    matrix_subtract(imu_ekf.I_matrix,temp_matrix9,temp_matrix10,4,4);
    matrix_multiply(temp_matrix10,imu_ekf.p_hat,temp_matrix11,4,4,4);
    matrix_copy(temp_matrix11,imu_ekf.p_hat,4,4);
    /*************************** æ›´æ–°åæ–¹å·®çŸ©é˜µ ****************************/
}
é‡è¦çš„äº‹æƒ…è¯´ä¸‰éï¼Œä¸€å®šè¦æ³¨æ„é‡‡æ ·å‘¨æœŸï¼ä¸€å®šè¦æ³¨æ„é‡‡æ ·å‘¨æœŸï¼ä¸€å®šè¦æ³¨æ„é‡‡æ ·å‘¨æœŸï¼

æœ€åï¼Œç»“å°¾ç•™ä¸€ä¸ªé—®é¢˜ï¼Œè¿™é‡Œçš„qçš„åˆå§‹å€¼ä¸ºä»€ä¹ˆæ˜¯  ,æ€ªä¸­ä¹‹æ€ªã€‚(è§è¯„è®ºåŒº)
ä¼˜åŒ–æ•ˆæœ
è¿™é‡Œå’Œçº¯åŠ é€Ÿåº¦åšå¯¹æ¯”ã€‚

åŠ é€Ÿåº¦è®¡è§£ç®—ä¸ekfè§£ç®—

å±€éƒ¨æ”¾å¤§
Vofa+ä¸Šä½æœºæŸ¥çœ‹mcuæ»¤æ³¢æ•ˆæœ

çº¢è‰²æ›²çº¿ä¸ºEKFä¼˜åŒ–ä¹‹åçš„ä¿¯ä»°è§’ï¼Œè“è‰²æ›²çº¿ä¸ºçº¯åŠ é€Ÿåº¦è®¡è§£ç®—
è¿™å¹…å›¾æ˜¯å¤§è§’åº¦å°æ‘†åŠ¨é€Ÿåº¦å’Œå°è§’åº¦å¤§æ‘†åŠ¨é€Ÿåº¦æµ‹å¾—çš„è§£ç®—æ›²çº¿ï¼Œå¾ˆæ˜æ˜¾çš„å¯ä»¥çœ‹åˆ°ï¼ŒEKFå¯¹è¿åŠ¨åŠ é€Ÿåº¦å¸¦æ¥çš„è¯¯å·®æœ‰ä¸é”™çš„æŠ‘åˆ¶æ•ˆæœã€‚
å§¿æ€è§£ç®—ä¿®æ­£
ä»Šå¤©åœ¨åšmatlabä»¿çœŸæ—¶ï¼Œå‘ç°å§¿æ€æ›´æ–°çš„å•ä½æœ‰ç‚¹é—®é¢˜ï¼Œä¸Šé¢çš„Cä»£ç éƒ¨åˆ†å·²ç»åŒæ­¥æ›´æ–°ã€‚

Rollè§’

Pitchè§’
åœ¨ä¿®æ”¹äº†å•ä½ä¹‹åï¼Œå¯ä»¥å¯¹æ¯”ä¹‹å‰çš„å›¾ç‰‡ï¼Œç›¸ä½æ»åå‡ ä¹æ²¡æœ‰äº†ï¼Œå†ç”¨ä¸Šçºä½¬çš„PQRä¸‰ä¸ªçŸ©é˜µçš„åˆå§‹å€¼ï¼Œæ•ˆæœå¯ä»¥åœ¨å¹³è¡¡è½¦ä¸Šæ­£å¸¸ä½¿ç”¨äº†ã€‚
æœ€è¿‘æ¯”è¾ƒå¿™ï¼ŒçŸ©é˜µè¿ç®—éƒ¨åˆ†è¿‡ä¸€é˜µå­ä¼šå¼€æºå‡ºæ¥ï¼Œä¸é™åˆ¶MCUçš„å¹³å°ï¼Œçº¯è½¯ä»¶çš„çŸ©é˜µç®—æ³•ï¼Œå› ä¸ºè¿™ä¸ªEKFåªç”¨åˆ°äº†ç‰¹æ®Šå°ºå¯¸çš„çŸ©é˜µè¿ç®—ï¼Œæ‰€ä»¥åº“é‡Œæœ‰é’ˆå¯¹æ€§çš„çŸ©é˜µè¿ç®—ã€‚
MATLABä»¿çœŸç¨‹åºä»¥åŠä¸²å£è¾“å‡ºæ–‡ä»¶
% åŠ è½½é™€èºä»ªæ•°æ®
% é¡ºåºax,ay,az,gx,gy,gz
% accçš„å•ä½æ˜¯g
% gyroçš„å•ä½æ˜¯deg/s
data = load('D:/Serial Debug 2023-12-25 215322.csv');

% è·å–æ•°æ®ä¸ªæ•° ä¸€ç»„æ•°æ® ax ay az gx gy gz  
numRows = size(data, 1); 

% è¿­ä»£æ¬¡æ•°
epoch = 2;

% æ¬§æ‹‰è§’
global eul_deg;
eul_deg = zeros(numRows*epoch,3);

% åŠ é€Ÿåº¦è®¡æ¬§æ‹‰è§’
global eul_acc_deg;
eul_acc_deg = zeros(numRows*epoch,2);

% æ›´æ–°å‘¨æœŸ
global period_T;
period_T = 0.001;

% æ›´æ–°å‘¨æœŸçš„ä¸€åŠ
global Half_T;
Half_T = period_T / 2;

 % æœºä½“å››å…ƒæ•°
global q; 
q = transpose([1 0 0 0]);

% è§‚æµ‹å‘é‡
global Z;

% çŠ¶æ€è½¬ç§»çŸ©é˜µ
global A;

% è§‚æµ‹çŸ©é˜µ
global H;

% è¯¯å·®åæ–¹å·®çŸ©é˜µ
global P;
P_value = 100000;
P_diag = [P_value P_value P_value P_value];
P = diag(P_diag);

% è¿‡ç¨‹å™ªå£°åæ–¹å·®çŸ©é˜µ
global Q;
Q_value = 0.01;
Q_diag = [Q_value Q_value Q_value Q_value];
Q = diag(Q_diag);

% æµ‹é‡å™ªå£°åæ–¹å·®çŸ©é˜µ
global R;
R_value = 1000000;
R_diag = [R_value R_value R_value];
R = diag(R_diag);

% å¡å°”æ›¼å¢ç›Š
global K;

global deg_num;
deg_num = 1;
for j = 1:epoch
    % ä½¿ç”¨forå¾ªç¯éå†æ¯ä¸€è¡Œ  
    for i = 1:numRows  
        % è®¿é—®å½“å‰è¡Œçš„æ‰€æœ‰å…ƒç´   
        row = data(i, :); % ä½¿ç”¨å†’å·æ¥é€‰æ‹©æ‰€æœ‰åˆ—  

        ax = row(1) * 9.8;
        ay = row(2) * 9.8;
        az = row(3) * 9.8;
        gx = row(4) / 57.3;
        gy = row(5)/ 57.3;
        gz = row(6)/ 57.3;

        % å…ˆéªŒä¼°è®¡
        A =  update_A(gx,gy,gz);
        q = A * q; 

        % è®¡ç®—å…ˆéªŒè¯¯å·®åæ–¹å·®
        AT = transpose(A);
        P = A*P*AT + Q;

        % æ›´æ–°è§‚æµ‹å‘é‡
        Z = transpose([ax,ay,az]);

        % æ›´æ–°è§‚æµ‹çŸ©é˜µ
        H = update_H(q);

        % è®¡ç®—å¡å°”æ›¼å¢ç›Š
        HT = transpose(H);
        K = (P*HT) / (H*P*HT+R);

        % åéªŒä¼°è®¡
        q = q + K * (Z - H*q);

        % æ›´æ–°è¯¯å·®åæ–¹å·®
        P = (eye(4) - K * H) * P;

        % æ¬§æ‹‰è§’è§£ç®—
        qt = transpose(q);
        eul = quat2eul(qt);  
        eul_deg(deg_num,:) = rad2deg(eul);

        eul_acc_deg(deg_num,1) = rad2deg(atan2(ay,az));
        eul_acc_deg(deg_num,2) = -rad2deg(atan(ax/sqrt(ay*ay+az*az)));
        deg_num = deg_num + 1;
    end
end

line_width = 2;
figure; % æ¿€æ´»ç¬¬ä¸‰ä¸ªå­å›¾  
plot(1:numRows*epoch, eul_deg(:,3), 'b-','LineWidth', line_width); % ç»˜åˆ¶æ»šè½¬è§’ï¼ˆrollï¼‰  
hold on; % ä¿æŒå½“å‰å›¾å½¢ï¼Œä»¥ä¾¿æ·»åŠ æ›´å¤šæ›²çº¿  
plot(1:numRows*epoch, eul_acc_deg(:,1), 'r-','LineWidth', line_width); % ç»˜åˆ¶æ»šè½¬è§’ï¼ˆrollï¼‰  
legend('ekf', 'acc');  
title('Pitch Angle (degrees)');  
xlabel('Time');  
ylabel('Angle'); 

figure; % æ¿€æ´»ç¬¬ä¸‰ä¸ªå­å›¾  
plot(1:numRows*epoch, eul_deg(:,2), 'b-','LineWidth', line_width); % ç»˜åˆ¶æ»šè½¬è§’ï¼ˆrollï¼‰  
hold on; % ä¿æŒå½“å‰å›¾å½¢ï¼Œä»¥ä¾¿æ·»åŠ æ›´å¤šæ›²çº¿  
plot(1:numRows*epoch, eul_acc_deg(:,2), 'r-','LineWidth', line_width); % ç»˜åˆ¶æ»šè½¬è§’ï¼ˆrollï¼‰  
legend('ekf', 'acc'); 
title('Roll Angle (degrees)');  
xlabel('Time');  
ylabel('Angle'); 


% çŠ¶æ€è½¬ç§»çŸ©é˜µæ›´æ–°
function A_Update = update_A(gx,gy,gz)
    global Half_T; 
    gx_ = gx * Half_T;
    gy_ = gy * Half_T;
    gz_ = gz * Half_T;
    A_Update = [  1  -gx_ -gy_  -gz_;
                 gx_  1    gz_  -gy_;
                 gy_ -gz_   1    gx_; 
                 gz_  gy_ -gx_    1 ;];
end

% æµ‹é‡çŸ©é˜µæ›´æ–°
function H_Update = update_H(q)
    q0 = q(1);
    q1 = q(2);
    q2 = q(3);
    q3 = q(4);
    
    H_Update = [-2*q2  2*q3 -2*q0 2*q1;
                 2*q1  2*q0  2*q3 2*q2;
                 2*q0 -2*q1 -2*q2 2*q3];
end
matlabä»¿çœŸè„šæœ¬ä»¥åŠxlxsä¸²å£æ•°æ®åœ°å€kalworth/EKF_Angle (github.com)
